name: Deploy Hugo Blog from GitLab to Cloudflare Pages

on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      DART_SASS_VERSION: 1.77.4 # Define the Dart Sass version globally for the job
      HUGO_VERSION: 0.148.0 # <-- Define your desired Hugo version here
      
    steps:
    # 1. Checkout Code from GitLab (Using SSH or Token to handle submodules)
    # We combine the clone and setup steps for better access control.
    - name: Checkout Code with Submodule Authentication
      env:
        # Use a variable name that Git can easily interpret as a token
        GIT_OAUTH_TOKEN: ${{ secrets.GITLAB_ACCESS_TOKEN }} 
      run: |
        # 1a. CRITICAL: Configure Git to replace all 'https://gitlab.com' 
        # URLs in the .gitmodules file with the authenticated token URL.
        # This ensures that git submodule update succeeds for private repos.
        git config --global url."https://oauth2:$GIT_OAUTH_TOKEN@gitlab.com".insteadOf "https://gitlab.com"
        
        # 1b. Clone the repository first using the token
        git clone https://gitlab.com/tejasjog/blog.git
        
        # 1b. Change directory to the cloned repo
        cd blog
        
    # 2. Run Submodule Update and Cleanup .git files
    - name: Update Submodules and Cleanup Content Directories
      # working-directory must be 'blog' now
      working-directory: blog
      run: |
        echo "Attempting to update submodules..."
        # 2a. Update/initialize all submodules. This now uses the authenticated URL.
        git submodule update --init --force --recursive --remote --verbose

        echo "## ðŸ“Š File Count Per Directory ##"
        echo "--------------------------------"
        
        # Find all directories (excluding the main .git folder)
        # The -path ./.git -prune part tells find to ignore the Git metadata directory.
        find . -path ./.git -prune -o -type d -print | while read dir; do
            
            # Use find again to count only files (-type f) within that specific directory ($dir)
            # The '2>/dev/null' suppresses any potential permission errors.
            file_count=$(find "$dir" -maxdepth 1 -type f 2>/dev/null | wc -l)
            
            # Print the count and the directory name.
            # The '{print $0}' ensures the directory name is used exactly as read.
            if [ "$file_count" -gt 0 ]; then
                echo "$file_count files in: $dir"
            fi
        done
        echo "--------------------------------"
        
        # Optional: Keep your original total count for comparison
        echo "Total files in repository (excluding .git):"
        find . -path ./.git -prune -o -type f -print | wc -l

    # NEW STEP: Install System Dependencies (Brotli and Dart Sass)
    - name: Install Brotli and Dart Sass
      # This step must run in the root of the runner before Node.js setup
      run: |
        echo "Installing system dependencies: brotli and Dart Sass..."
        
        # Install brotli
        sudo apt-get update
        sudo apt-get install -y brotli
        
        # Install Dart Sass
        # Note: We use the DART_SASS_VERSION environment variable defined above.
        DART_SASS_FILENAME="dart-sass-${{ env.DART_SASS_VERSION }}-linux-x64.tar.gz"
        curl -LJO https://github.com/sass/dart-sass/releases/download/${{ env.DART_SASS_VERSION }}/$DART_SASS_FILENAME
        tar -xf $DART_SASS_FILENAME
        
        # Move the executables to a standard PATH location
        sudo cp -r dart-sass/* /usr/local/bin/
        
        # Clean up downloaded files
        rm -rf dart-sass*
        
        # The /usr/local/bin is already in the system PATH, so an explicit export is not necessary 
        # for subsequent steps in the same job, but we'll confirm the files are there.
        echo "Dart Sass installed to /usr/local/bin"
        
        # Install Hugo
        sudo curl -LJO https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb
        sudo apt-get install -y ./hugo_extended_${HUGO_VERSION}_linux-amd64.deb
        sudo rm hugo_extended_${HUGO_VERSION}_linux-amd64.deb

        # Install Node.js
        sudo curl -fsSL https://deb.nodesource.com/setup_${NODE_VERSION} | bash -
        sudo apt-get install -y nodejs

    # 5. Install Node Dependencies (npm install)
    - name: Install Node Dependencies
      run: npm install
      working-directory: blog 
        
    # 6B. Build Hugo Site
    - name: Build Hugo Site
      run: |
        # The 'hugo' command is now available on PATH from the previous step.
        hugo --gc --minify --baseURL ${{ vars.CI_CF_PAGES_URL || 'https://tejasjog-blog.pages.dev/' }} --destination public-cf --logLevel debug --environment production
      working-directory: blog

    # --- NEW STEP FOR CLEANUP ---
    # 6C. Cloudflare Cleanup: Delete files specified in .droplist
    - name: Cloudflare Cleanup Delete .droplist Files
      working-directory: blog
      run: |
        echo "Searching for .droplist files..."
        # 1. Use 'find' to locate all files with the .droplist extension within the output directory.
        DROPLIST_FILES=$(find public-cf -name "*.droplist")
        if [ -z "$DROPLIST_FILES" ]; then
          echo "No .droplist files found. Exiting cleanup."
        fi
        
        # 2. Iterate through each .droplist file found.
        for DROPLIST_FILE in $DROPLIST_FILES; do
          echo "Processing $DROPLIST_FILE..."
          # Get the directory of the .droplist file to resolve relative paths.
          # Example: If file is public-cf/posts/_index.html.droplist, DIR is public-cf/posts
          DROPLIST_DIR=$(dirname "$DROPLIST_FILE")

          # 3. Read the content of the .droplist file line by line.
          while IFS= read -r FILE_TO_DELETE; do
            # Exit if line is empty
            [ -z "$FILE_TO_DELETE" ] && continue

            # Extract filename and extension
            filename="${FILE_TO_DELETE%.*}"
            extension="${FILE_TO_DELETE##*.}"
            
            # Create lowercase and uppercase extension variants (Hugo generates both)
            LOWERCASE_EXTENSION=$(echo "$extension" | tr '[:upper:]' '[:lower:]')
            UPPERCASE_EXTENSION="${extension^^}"
            
            # Rebuild the full filename with the modified extension(s)
            if [ "$filename" != "$FILE_TO_DELETE" ]; then
              # File with extension (e.g., 'image.JPG')
              FULL_PATH_TO_DELETE_LOWERCASE_EXTENSION="$DROPLIST_DIR/${filename}.${LOWERCASE_EXTENSION}"
              FULL_PATH_TO_DELETE_UPPERCASE_EXTENSION="$DROPLIST_DIR/${filename}.${UPPERCASE_EXTENSION}"
            else
              # Case for files without an extension (just the original filename)
              FULL_PATH_TO_DELETE_LOWERCASE_EXTENSION="$DROPLIST_DIR/$FILE_TO_DELETE"
              FULL_PATH_TO_DELETE_UPPERCASE_EXTENSION="" # No uppercase check needed for no-ext files
            fi

            # Check and delete the lowercase extension variant
            if [ -f "$FULL_PATH_TO_DELETE_LOWERCASE_EXTENSION" ]; then
              echo "Deleting file: $FULL_PATH_TO_DELETE_LOWERCASE_EXTENSION"
              rm "$FULL_PATH_TO_DELETE_LOWERCASE_EXTENSION"
            else
              echo "Warning: File not found - $FULL_PATH_TO_DELETE_LOWERCASE_EXTENSION"
            fi

            # Check and delete the uppercase extension variant (only if an extension existed)
            if [ -n "$FULL_PATH_TO_DELETE_UPPERCASE_EXTENSION" ] && [ -f "$FULL_PATH_TO_DELETE_UPPERCASE_EXTENSION" ]; then
              echo "Deleting file: $FULL_PATH_TO_DELETE_UPPERCASE_EXTENSION"
              rm "$FULL_PATH_TO_DELETE_UPPERCASE_EXTENSION"
            fi
            
          done < "$DROPLIST_FILE"
          
          # Optional: Delete the .droplist file itself after processing
          rm "$DROPLIST_FILE"
        done    
    # --- END NEW STEP ---

    # 7a. Install Wrangler (Globally installed)
    - name: Install Wrangler
      run: npm install -g wrangler
  
    # 7b. Deploy to Cloudflare Pages
    - name: Deploy to Cloudflare Pages
      uses: cloudflare/pages-action@v1 
      with:
        apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        projectName: 'tejasjog-blog'
        directory: 'blog/public-cf' 
        branch: 'master'

    # 8a. Install Netlify CLI (Required for Netlify deployment)
    - name: Install Netlify CLI
      run: npm install netlify-cli -g

    # 8b. Deploy to Netlify
    - name: Deploy to Netlify
      # Netlify requires a separate output directory or the use of --dir.
      # Since we only built into 'public-cf', we must copy the content first.
      working-directory: blog
      run: |
        echo "Copying Cloudflare build output (public-cf) to Netlify target (public-netlify)..."
        # Create a new directory for Netlify's deployment
        mkdir -p public-netlify
        # Copy the contents of the Cloudflare build to the Netlify directory
        cp -R public-cf/* public-netlify/
        
        echo "Starting Netlify deployment..."
        # Deploy the copied directory
        netlify deploy --prod --dir public-netlify --site ${{ secrets.NETLIFY_SITE_ID }}
      env:
        # Pass the token for authentication
        NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_ACCESS_TOKEN }}
        
    # --- END DUAL DEPLOYMENT STEPS ---  

